-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\L3G4200D_SPI\hdl_dut.vhd
-- Created: 2015-04-14 21:31:24
-- 
-- Generated by MATLAB 8.5 and HDL Coder 3.6
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Model base rate: 1
-- Target subsystem base rate: 1
-- 
-- 
-- Clock Enable  Sample Time
-- -------------------------------------------------------------
-- ce_out        1
-- -------------------------------------------------------------
-- 
-- 
-- Output Signal                 Clock Enable  Sample Time
-- -------------------------------------------------------------
-- x_gyro_low                    ce_out        1
-- x_gyro_out                    ce_out        1
-- y_gyro_low                    ce_out        1
-- y_gyro_out                    ce_out        1
-- z_gyro_low                    ce_out        1
-- z_gyro_out                    ce_out        1
-- who_am_i                      ce_out        1
-- SCLK                          ce_out        1
-- CS                            ce_out        1
-- SDI                           ce_out        1
-- -------------------------------------------------------------
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: hdl_dut
-- Source Path: L3G4200D_SPI/hdl_dut
-- Hierarchy Level: 0
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.hdl_dut_pkg.ALL;

ENTITY hdl_dut IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        clk_enable                        :   IN    std_logic;
        enable                            :   IN    std_logic;
        SDO                               :   IN    std_logic;
        ce_out                            :   OUT   std_logic;
        x_gyro_low                        :   OUT   std_logic_vector(7 DOWNTO 0);  -- int8
        x_gyro_out                        :   OUT   std_logic_vector(7 DOWNTO 0);  -- int8
        y_gyro_low                        :   OUT   std_logic_vector(7 DOWNTO 0);  -- int8
        y_gyro_out                        :   OUT   std_logic_vector(7 DOWNTO 0);  -- int8
        z_gyro_low                        :   OUT   std_logic_vector(7 DOWNTO 0);  -- int8
        z_gyro_out                        :   OUT   std_logic_vector(7 DOWNTO 0);  -- int8
        who_am_i                          :   OUT   std_logic_vector(7 DOWNTO 0);  -- int8
        SCLK                              :   OUT   std_logic;
        CS                                :   OUT   std_logic;
        SDI                               :   OUT   std_logic
        );
END hdl_dut;


ARCHITECTURE rtl OF hdl_dut IS

  -- Component Declarations
  COMPONENT Incremental_Counter
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          Inc                             :   IN    std_logic;
          Out_rsvd                        :   OUT   std_logic_vector(15 DOWNTO 0)  -- uint16
          );
  END COMPONENT;

  COMPONENT Initialized_Check
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          in_rsvd                         :   IN    std_logic_vector(15 DOWNTO 0);  -- uint16
          out_rsvd                        :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT Detect_Increase1
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          U                               :   IN    std_logic;
          Y                               :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT Transmit
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          transmit_begin                  :   IN    std_logic;
          data                            :   IN    std_logic_vector(15 DOWNTO 0);  -- uint16
          rw_bit                          :   IN    std_logic;
          MISO                            :   IN    std_logic;
          read_data                       :   OUT   std_logic_vector(7 DOWNTO 0);  -- uint8
          data_valid                      :   OUT   std_logic;
          CLK_1                           :   OUT   std_logic;
          CS                              :   OUT   std_logic;
          MOSI                            :   OUT   std_logic;
          ready                           :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT Incremental_Counter1
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          Inc                             :   IN    std_logic;
          Out_rsvd                        :   OUT   std_logic_vector(15 DOWNTO 0)  -- uint16
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : Incremental_Counter
    USE ENTITY work.Incremental_Counter(rtl);

  FOR ALL : Initialized_Check
    USE ENTITY work.Initialized_Check(rtl);

  FOR ALL : Detect_Increase1
    USE ENTITY work.Detect_Increase1(rtl);

  FOR ALL : Transmit
    USE ENTITY work.Transmit(rtl);

  FOR ALL : Incremental_Counter1
    USE ENTITY work.Incremental_Counter1(rtl);

  -- Signals
  SIGNAL enb                              : std_logic;
  SIGNAL Delay2_out1                      : std_logic;
  SIGNAL Constant1_out1                   : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL Constant2_out1                   : vector_of_unsigned16(0 TO 6);  -- uint16 [7]
  SIGNAL Delay3_out1                      : std_logic;
  SIGNAL address                          : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL Bit_Slice2_out1                  : std_logic;  -- ufix1
  SIGNAL Data_Type_Conversion2_out1       : std_logic;
  SIGNAL index_counter                    : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL index_counter_unsigned           : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL address_1                        : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL enable_1                         : std_logic;
  SIGNAL out_rsvd                         : std_logic;
  SIGNAL switch_compare_1                 : std_logic;
  SIGNAL ready                            : std_logic;
  SIGNAL Delay1_out1                      : std_logic;
  SIGNAL Detect_Increase1_out1            : std_logic;
  SIGNAL read_data                        : std_logic_vector(7 DOWNTO 0);  -- ufix8
  SIGNAL data_valid                       : std_logic;
  SIGNAL CLK_1                            : std_logic;
  SIGNAL CS_1                             : std_logic;
  SIGNAL MOSI                             : std_logic;
  SIGNAL read_data_unsigned               : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL Data_Type_Conversion1_out1       : signed(7 DOWNTO 0);  -- int8
  SIGNAL Incremental_Counter1_out1        : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL Incremental_Counter1_out1_unsigned : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL Assignment_out1                  : vector_of_signed8(0 TO 6);  -- int8 [7]
  SIGNAL Delay_out1                       : vector_of_signed8(0 TO 6);  -- int8 [7]
  SIGNAL x_gyro_low_1                     : signed(7 DOWNTO 0);  -- int8
  SIGNAL Delay4_out1                      : signed(7 DOWNTO 0);  -- int8
  SIGNAL x_gyro_out_1                     : signed(7 DOWNTO 0);  -- int8
  SIGNAL Delay5_out1                      : signed(7 DOWNTO 0);  -- int8
  SIGNAL y_gyro_low_1                     : signed(7 DOWNTO 0);  -- int8
  SIGNAL Delay6_out1                      : signed(7 DOWNTO 0);  -- int8
  SIGNAL y_gyro_out_1                     : signed(7 DOWNTO 0);  -- int8
  SIGNAL Delay7_out1                      : signed(7 DOWNTO 0);  -- int8
  SIGNAL z_gyro_low_1                     : signed(7 DOWNTO 0);  -- int8
  SIGNAL Delay8_out1                      : signed(7 DOWNTO 0);  -- int8
  SIGNAL z_gyro_out_1                     : signed(7 DOWNTO 0);  -- int8
  SIGNAL Delay9_out1                      : signed(7 DOWNTO 0);  -- int8
  SIGNAL who_am_i_1                       : signed(7 DOWNTO 0);  -- int8
  SIGNAL Delay10_out1                     : signed(7 DOWNTO 0);  -- int8
  SIGNAL Delay17_out1                     : std_logic;
  SIGNAL Delay18_out1                     : std_logic;
  SIGNAL Delay19_out1                     : std_logic;

BEGIN
  -- Assign new sensor data to output array based on current count
  -- 
  -- Assigned to PMOD pins out

  u_Incremental_Counter : Incremental_Counter
    PORT MAP( clk => clk,
              reset => reset,
              enb => clk_enable,
              Inc => enable_1,
              Out_rsvd => index_counter  -- uint16
              );

  u_Initialized_Check : Initialized_Check
    PORT MAP( clk => clk,
              reset => reset,
              enb => clk_enable,
              in_rsvd => index_counter,  -- uint16
              out_rsvd => out_rsvd
              );

  u_Detect_Increase1 : Detect_Increase1
    PORT MAP( clk => clk,
              reset => reset,
              enb => clk_enable,
              U => enable_1,
              Y => Detect_Increase1_out1
              );

  u_Transmit : Transmit
    PORT MAP( clk => clk,
              reset => reset,
              enb => clk_enable,
              transmit_begin => Detect_Increase1_out1,
              data => std_logic_vector(address),  -- uint16
              rw_bit => Data_Type_Conversion2_out1,
              MISO => Delay3_out1,
              read_data => read_data,  -- uint8
              data_valid => data_valid,
              CLK_1 => CLK_1,
              CS => CS_1,
              MOSI => MOSI,
              ready => ready
              );

  u_Incremental_Counter1 : Incremental_Counter1
    PORT MAP( clk => clk,
              reset => reset,
              enb => clk_enable,
              Inc => data_valid,
              Out_rsvd => Incremental_Counter1_out1  -- uint16
              );

  enb <= clk_enable;

  Delay2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay2_out1 <= '1';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay2_out1 <= enable;
      END IF;
    END IF;
  END PROCESS Delay2_process;


  Constant1_out1 <= to_unsigned(16#20CF#, 16);

  Constant2_out1(0) <= to_unsigned(16#A800#, 16);
  Constant2_out1(1) <= to_unsigned(16#A900#, 16);
  Constant2_out1(2) <= to_unsigned(16#AA00#, 16);
  Constant2_out1(3) <= to_unsigned(16#AB00#, 16);
  Constant2_out1(4) <= to_unsigned(16#AC00#, 16);
  Constant2_out1(5) <= to_unsigned(16#AD00#, 16);
  Constant2_out1(6) <= to_unsigned(16#8F00#, 16);

  Delay3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay3_out1 <= '1';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay3_out1 <= SDO;
      END IF;
    END IF;
  END PROCESS Delay3_process;


  Bit_Slice2_out1 <= address(15);

  
  Data_Type_Conversion2_out1 <= '1' WHEN Bit_Slice2_out1 /= '0' ELSE
      '0';

  index_counter_unsigned <= unsigned(index_counter);

  
  address_1 <= Constant2_out1(0) WHEN index_counter_unsigned = to_unsigned(16#0001#, 16) ELSE
      Constant2_out1(1) WHEN index_counter_unsigned = to_unsigned(16#0002#, 16) ELSE
      Constant2_out1(2) WHEN index_counter_unsigned = to_unsigned(16#0003#, 16) ELSE
      Constant2_out1(3) WHEN index_counter_unsigned = to_unsigned(16#0004#, 16) ELSE
      Constant2_out1(4) WHEN index_counter_unsigned = to_unsigned(16#0005#, 16) ELSE
      Constant2_out1(5) WHEN index_counter_unsigned = to_unsigned(16#0006#, 16) ELSE
      Constant2_out1(6);

  
  switch_compare_1 <= '1' WHEN out_rsvd > '0' ELSE
      '0';

  
  address <= Constant1_out1 WHEN switch_compare_1 = '0' ELSE
      address_1;

  Delay1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay1_out1 <= '1';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay1_out1 <= ready;
      END IF;
    END IF;
  END PROCESS Delay1_process;


  enable_1 <= Delay2_out1 AND Delay1_out1;

  read_data_unsigned <= unsigned(read_data);

  Data_Type_Conversion1_out1 <= signed(read_data_unsigned);

  Incremental_Counter1_out1_unsigned <= unsigned(Incremental_Counter1_out1);

  Delay_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay_out1 <= (OTHERS => to_signed(16#00#, 8));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay_out1 <= Assignment_out1;
      END IF;
    END IF;
  END PROCESS Delay_process;


  
  Assignment_out1(0) <= Data_Type_Conversion1_out1 WHEN Incremental_Counter1_out1_unsigned = to_unsigned(16#0001#, 16) ELSE
      Delay_out1(0);
  
  Assignment_out1(1) <= Data_Type_Conversion1_out1 WHEN Incremental_Counter1_out1_unsigned = to_unsigned(16#0002#, 16) ELSE
      Delay_out1(1);
  
  Assignment_out1(2) <= Data_Type_Conversion1_out1 WHEN Incremental_Counter1_out1_unsigned = to_unsigned(16#0003#, 16) ELSE
      Delay_out1(2);
  
  Assignment_out1(3) <= Data_Type_Conversion1_out1 WHEN Incremental_Counter1_out1_unsigned = to_unsigned(16#0004#, 16) ELSE
      Delay_out1(3);
  
  Assignment_out1(4) <= Data_Type_Conversion1_out1 WHEN Incremental_Counter1_out1_unsigned = to_unsigned(16#0005#, 16) ELSE
      Delay_out1(4);
  
  Assignment_out1(5) <= Data_Type_Conversion1_out1 WHEN Incremental_Counter1_out1_unsigned = to_unsigned(16#0006#, 16) ELSE
      Delay_out1(5);
  
  Assignment_out1(6) <= Data_Type_Conversion1_out1 WHEN Incremental_Counter1_out1_unsigned = to_unsigned(16#0007#, 16) ELSE
      Delay_out1(6);

  x_gyro_low_1 <= Assignment_out1(0);

  Delay4_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay4_out1 <= to_signed(16#00#, 8);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay4_out1 <= x_gyro_low_1;
      END IF;
    END IF;
  END PROCESS Delay4_process;


  x_gyro_low <= std_logic_vector(Delay4_out1);

  x_gyro_out_1 <= Assignment_out1(1);

  Delay5_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay5_out1 <= to_signed(16#00#, 8);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay5_out1 <= x_gyro_out_1;
      END IF;
    END IF;
  END PROCESS Delay5_process;


  x_gyro_out <= std_logic_vector(Delay5_out1);

  y_gyro_low_1 <= Assignment_out1(2);

  Delay6_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay6_out1 <= to_signed(16#00#, 8);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay6_out1 <= y_gyro_low_1;
      END IF;
    END IF;
  END PROCESS Delay6_process;


  y_gyro_low <= std_logic_vector(Delay6_out1);

  y_gyro_out_1 <= Assignment_out1(3);

  Delay7_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay7_out1 <= to_signed(16#00#, 8);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay7_out1 <= y_gyro_out_1;
      END IF;
    END IF;
  END PROCESS Delay7_process;


  y_gyro_out <= std_logic_vector(Delay7_out1);

  z_gyro_low_1 <= Assignment_out1(4);

  Delay8_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay8_out1 <= to_signed(16#00#, 8);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay8_out1 <= z_gyro_low_1;
      END IF;
    END IF;
  END PROCESS Delay8_process;


  z_gyro_low <= std_logic_vector(Delay8_out1);

  z_gyro_out_1 <= Assignment_out1(5);

  Delay9_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay9_out1 <= to_signed(16#00#, 8);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay9_out1 <= z_gyro_out_1;
      END IF;
    END IF;
  END PROCESS Delay9_process;


  z_gyro_out <= std_logic_vector(Delay9_out1);

  who_am_i_1 <= Assignment_out1(6);

  Delay10_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay10_out1 <= to_signed(16#00#, 8);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay10_out1 <= who_am_i_1;
      END IF;
    END IF;
  END PROCESS Delay10_process;


  who_am_i <= std_logic_vector(Delay10_out1);

  Delay17_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay17_out1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay17_out1 <= CLK_1;
      END IF;
    END IF;
  END PROCESS Delay17_process;


  Delay18_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay18_out1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay18_out1 <= CS_1;
      END IF;
    END IF;
  END PROCESS Delay18_process;


  Delay19_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay19_out1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay19_out1 <= MOSI;
      END IF;
    END IF;
  END PROCESS Delay19_process;


  ce_out <= clk_enable;


  SCLK <= Delay17_out1;

  CS <= Delay18_out1;

  SDI <= Delay19_out1;

END rtl;

