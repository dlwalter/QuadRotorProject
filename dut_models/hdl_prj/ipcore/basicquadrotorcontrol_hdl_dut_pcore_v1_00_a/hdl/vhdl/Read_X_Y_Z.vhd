-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\BasicQuadrotorControl\Read_X_Y_Z.vhd
-- Created: 2015-02-18 16:12:25
-- 
-- Generated by MATLAB 8.4 and HDL Coder 3.5
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: Read_X_Y_Z
-- Source Path: BasicQuadrotorControl/hdl_dut/ADXL345_read/Read_X_Y_Z
-- Hierarchy Level: 2
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.hdl_dut_pkg.ALL;

ENTITY Read_X_Y_Z IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        read_x_y_z_en                     :   IN    std_logic;
        CSn                               :   OUT   std_logic;
        SCK                               :   OUT   std_logic;
        SDI                               :   OUT   std_logic;
        READ_SHIFT                        :   OUT   std_logic;
        XYZ_Valid                         :   OUT   std_logic
        );
END Read_X_Y_Z;


ARCHITECTURE rtl OF Read_X_Y_Z IS

  -- Signals
  SIGNAL is_Read_X_Y_Z                    : T_state_type_is_Read_X_Y_Z;  -- uint8
  SIGNAL count                            : unsigned(8 DOWNTO 0);  -- ufix9
  SIGNAL clock_cnt                        : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL CSn_reg                          : std_logic;
  SIGNAL SCK_reg                          : std_logic;
  SIGNAL SDI_reg                          : std_logic;
  SIGNAL READ_SHIFT_reg                   : std_logic;
  SIGNAL XYZ_Valid_reg                    : std_logic;
  SIGNAL is_Read_X_Y_Z_next               : T_state_type_is_Read_X_Y_Z;  -- enum type state_type_is_Read_X_Y_Z (8 enums)
  SIGNAL count_next                       : unsigned(8 DOWNTO 0);  -- ufix9
  SIGNAL clock_cnt_next                   : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL CSn_reg_next                     : std_logic;
  SIGNAL SCK_reg_next                     : std_logic;
  SIGNAL SDI_reg_next                     : std_logic;
  SIGNAL READ_SHIFT_reg_next              : std_logic;
  SIGNAL XYZ_Valid_reg_next               : std_logic;

BEGIN
  Read_X_Y_Z_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      count <= to_unsigned(2#000000000#, 9);
      clock_cnt <= to_unsigned(2#000000#, 6);
      CSn_reg <= '1';
      SCK_reg <= '1';
      SDI_reg <= '1';
      READ_SHIFT_reg <= '0';
      XYZ_Valid_reg <= '1';
      is_Read_X_Y_Z <= IN_IDLE;
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        is_Read_X_Y_Z <= is_Read_X_Y_Z_next;
        count <= count_next;
        clock_cnt <= clock_cnt_next;
        CSn_reg <= CSn_reg_next;
        SCK_reg <= SCK_reg_next;
        SDI_reg <= SDI_reg_next;
        READ_SHIFT_reg <= READ_SHIFT_reg_next;
        XYZ_Valid_reg <= XYZ_Valid_reg_next;
      END IF;
    END IF;
  END PROCESS Read_X_Y_Z_1_process;
  Read_X_Y_Z_1_output : PROCESS (is_Read_X_Y_Z, read_x_y_z_en, count, clock_cnt, CSn_reg, SCK_reg, SDI_reg,
       READ_SHIFT_reg, XYZ_Valid_reg)
    VARIABLE cnt : unsigned(4 DOWNTO 0);
    VARIABLE cnt_0 : unsigned(4 DOWNTO 0);
    VARIABLE ser_data_int : std_logic;
    VARIABLE add_temp : unsigned(9 DOWNTO 0);
    VARIABLE add_temp_0 : unsigned(9 DOWNTO 0);
    VARIABLE add_temp_1 : unsigned(9 DOWNTO 0);
    VARIABLE add_temp_2 : unsigned(9 DOWNTO 0);
    VARIABLE add_temp_3 : unsigned(6 DOWNTO 0);
    VARIABLE add_temp_4 : unsigned(9 DOWNTO 0);
    VARIABLE add_temp_5 : unsigned(9 DOWNTO 0);
    VARIABLE add_temp_6 : unsigned(9 DOWNTO 0);
    VARIABLE add_temp_7 : unsigned(6 DOWNTO 0);
    VARIABLE add_temp_8 : unsigned(6 DOWNTO 0);
    VARIABLE add_temp_9 : unsigned(6 DOWNTO 0);
  BEGIN
    is_Read_X_Y_Z_next <= is_Read_X_Y_Z;
    count_next <= count;
    clock_cnt_next <= clock_cnt;
    CSn_reg_next <= CSn_reg;
    SCK_reg_next <= SCK_reg;
    SDI_reg_next <= SDI_reg;
    READ_SHIFT_reg_next <= READ_SHIFT_reg;
    XYZ_Valid_reg_next <= XYZ_Valid_reg;

    CASE is_Read_X_Y_Z IS
      WHEN IN_CLOCKING =>
        --tCoONV time is typical 3 uS and Maximum 3.5 uS according to ADC data sheet.  Assuming clock frequency of 100 MHz, the maximum count value for 3 uS delay should be (3 uS/10 nS=) 300.
        IF count = to_unsigned(2#000001010#, 9) THEN 
          count_next <= to_unsigned(2#000000000#, 9);
          SCK_reg_next <= '1';
          add_temp_8 := resize(clock_cnt, 7) + to_unsigned(2#0000001#, 7);
          IF add_temp_8(6) /= '0' THEN 
            clock_cnt_next <= "111111";
          ELSE 
            clock_cnt_next <= add_temp_8(5 DOWNTO 0);
          END IF;
          is_Read_X_Y_Z_next <= IN_START_ADC_RDWR;
        ELSE 
          add_temp_2 := resize(count, 10) + to_unsigned(2#0000000001#, 10);
          IF add_temp_2(9) /= '0' THEN 
            count_next <= "111111111";
          ELSE 
            count_next <= add_temp_2(8 DOWNTO 0);
          END IF;
          is_Read_X_Y_Z_next <= IN_CLOCKING;
        END IF;
      WHEN IN_END =>
        IF count = to_unsigned(2#000001010#, 9) THEN 
          CSn_reg_next <= '1';
          count_next <= to_unsigned(2#000000000#, 9);
          XYZ_Valid_reg_next <= '1';
          READ_SHIFT_reg_next <= '0';
          is_Read_X_Y_Z_next <= IN_IDLE;
        ELSE 
          add_temp := resize(count, 10) + to_unsigned(2#0000000001#, 10);
          IF add_temp(9) /= '0' THEN 
            count_next <= "111111111";
          ELSE 
            count_next <= add_temp(8 DOWNTO 0);
          END IF;
          is_Read_X_Y_Z_next <= IN_END;
        END IF;
      WHEN IN_IDLE =>
        IF read_x_y_z_en = '1' THEN 
          CSn_reg_next <= '0';
          add_temp_3 := resize(clock_cnt, 7) + to_unsigned(2#0000001#, 7);
          IF add_temp_3(6) /= '0' THEN 
            clock_cnt_next <= "111111";
          ELSE 
            clock_cnt_next <= add_temp_3(5 DOWNTO 0);
          END IF;
          XYZ_Valid_reg_next <= '0';
          is_Read_X_Y_Z_next <= IN_START_CONV;
        END IF;
      WHEN IN_Read =>
        IF (count = to_unsigned(2#000001010#, 9)) AND (clock_cnt = to_unsigned(2#111000#, 6)) THEN 
          count_next <= to_unsigned(2#000000000#, 9);
          clock_cnt_next <= to_unsigned(2#000000#, 6);
          SCK_reg_next <= '1';
          is_Read_X_Y_Z_next <= IN_END;
        ELSIF count = to_unsigned(2#000001010#, 9) THEN 
          SCK_reg_next <= '1';
          count_next <= to_unsigned(2#000000000#, 9);
          add_temp_9 := resize(clock_cnt, 7) + to_unsigned(2#0000001#, 7);
          IF add_temp_9(6) /= '0' THEN 
            clock_cnt_next <= "111111";
          ELSE 
            clock_cnt_next <= add_temp_9(5 DOWNTO 0);
          END IF;
          is_Read_X_Y_Z_next <= IN_Read1;
        ELSE 
          add_temp_4 := resize(count, 10) + to_unsigned(2#0000000001#, 10);
          IF add_temp_4(9) /= '0' THEN 
            count_next <= "111111111";
          ELSE 
            count_next <= add_temp_4(8 DOWNTO 0);
          END IF;
          is_Read_X_Y_Z_next <= IN_Read;
        END IF;
      WHEN IN_Read1 =>
        IF count = to_unsigned(2#000001010#, 9) THEN 
          SCK_reg_next <= '0';
          count_next <= to_unsigned(2#000000000#, 9);
          is_Read_X_Y_Z_next <= IN_Read;
        ELSE 
          add_temp_0 := resize(count, 10) + to_unsigned(2#0000000001#, 10);
          IF add_temp_0(9) /= '0' THEN 
            count_next <= "111111111";
          ELSE 
            count_next <= add_temp_0(8 DOWNTO 0);
          END IF;
          is_Read_X_Y_Z_next <= IN_Read1;
        END IF;
      WHEN IN_START_ADC_RDWR =>
        --The ADC maximum clock frequency, according to ADC data sheet, is rated at 40 MHz.  Assuming a 100 MHz FPGA clock dividing the FPGA clock by 3 to generate a 33.33 MHz ADC clock (SCK) for the ADC.
        IF (clock_cnt = to_unsigned(2#001001#, 6)) AND (count = to_unsigned(2#000001010#, 9)) THEN 
          count_next <= to_unsigned(2#000000000#, 9);
          SCK_reg_next <= '0';
          SDI_reg_next <= '1';
          READ_SHIFT_reg_next <= '1';
          is_Read_X_Y_Z_next <= IN_Read;
        ELSIF count = to_unsigned(2#000001010#, 9) THEN 
          count_next <= to_unsigned(2#000000000#, 9);
          SCK_reg_next <= '0';
          IF clock_cnt(5) /= '0' THEN 
            cnt := "11111";
          ELSE 
            cnt := clock_cnt(4 DOWNTO 0);
          END IF;
          IF cnt = to_unsigned(2#00001#, 5) THEN 
            SDI_reg_next <= '1';
          ELSIF cnt = to_unsigned(2#00010#, 5) THEN 
            SDI_reg_next <= '1';
          ELSIF cnt = to_unsigned(2#00011#, 5) THEN 
            SDI_reg_next <= '1';
          ELSIF cnt = to_unsigned(2#00100#, 5) THEN 
            SDI_reg_next <= '1';
          ELSIF cnt = to_unsigned(2#00101#, 5) THEN 
            SDI_reg_next <= '0';
          ELSIF cnt = to_unsigned(2#00110#, 5) THEN 
            SDI_reg_next <= '0';
          ELSIF cnt = to_unsigned(2#00111#, 5) THEN 
            SDI_reg_next <= '1';
          ELSIF cnt = to_unsigned(2#01000#, 5) THEN 
            SDI_reg_next <= '0';
          ELSE 
            SDI_reg_next <= '1';
          END IF;
          is_Read_X_Y_Z_next <= IN_CLOCKING;
        ELSE 
          add_temp_6 := resize(count, 10) + to_unsigned(2#0000000001#, 10);
          IF add_temp_6(9) /= '0' THEN 
            count_next <= "111111111";
          ELSE 
            count_next <= add_temp_6(8 DOWNTO 0);
          END IF;
          is_Read_X_Y_Z_next <= IN_START_ADC_RDWR;
        END IF;
      WHEN IN_START_CONV =>
        --During START_CONV the CSn_CONV is held high for 10 clock cycles.  
        --Assuming the FPGA clock frequency is 100 MHz, the 10 clock count delay 
        --provides 100 nS delay which is the typical time specified in the ADC data 
        --sheet for the CSn_CONV input to the ADC.
        --The count comparator can be changed from 10 by the user as long as the ADC requirment for minimum of 40 nS is met.
        IF count = to_unsigned(2#000001010#, 9) THEN 
          count_next <= to_unsigned(2#000000000#, 9);
          SCK_reg_next <= '0';
          IF clock_cnt(5) /= '0' THEN 
            cnt_0 := "11111";
          ELSE 
            cnt_0 := clock_cnt(4 DOWNTO 0);
          END IF;
          IF cnt_0 = to_unsigned(2#00001#, 5) THEN 
            ser_data_int := '1';
          ELSIF cnt_0 = to_unsigned(2#00010#, 5) THEN 
            ser_data_int := '1';
          ELSIF cnt_0 = to_unsigned(2#00011#, 5) THEN 
            ser_data_int := '1';
          ELSIF cnt_0 = to_unsigned(2#00100#, 5) THEN 
            ser_data_int := '1';
          ELSIF cnt_0 = to_unsigned(2#00101#, 5) THEN 
            ser_data_int := '0';
          ELSIF cnt_0 = to_unsigned(2#00110#, 5) THEN 
            ser_data_int := '0';
          ELSIF cnt_0 = to_unsigned(2#00111#, 5) THEN 
            ser_data_int := '1';
          ELSIF cnt_0 = to_unsigned(2#01000#, 5) THEN 
            ser_data_int := '0';
          ELSE 
            ser_data_int := '1';
          END IF;
          SDI_reg_next <= ser_data_int;
          -- sending Read bit
          is_Read_X_Y_Z_next <= IN_tCONV_delay;
        ELSE 
          add_temp_5 := resize(count, 10) + to_unsigned(2#0000000001#, 10);
          IF add_temp_5(9) /= '0' THEN 
            count_next <= "111111111";
          ELSE 
            count_next <= add_temp_5(8 DOWNTO 0);
          END IF;
          is_Read_X_Y_Z_next <= IN_START_CONV;
        END IF;
      WHEN OTHERS => 
        --tCoONV time is typical 3 uS and Maximum 3.5 uS according to ADC data sheet.  Assuming clock frequency of 100 MHz, the maximum count value for 3 uS delay should be (3 uS/10 nS=) 300.
        IF count = to_unsigned(2#000001010#, 9) THEN 
          count_next <= to_unsigned(2#000000000#, 9);
          SCK_reg_next <= '1';
          add_temp_7 := resize(clock_cnt, 7) + to_unsigned(2#0000001#, 7);
          IF add_temp_7(6) /= '0' THEN 
            clock_cnt_next <= "111111";
          ELSE 
            clock_cnt_next <= add_temp_7(5 DOWNTO 0);
          END IF;
          is_Read_X_Y_Z_next <= IN_START_ADC_RDWR;
        ELSE 
          add_temp_1 := resize(count, 10) + to_unsigned(2#0000000001#, 10);
          IF add_temp_1(9) /= '0' THEN 
            count_next <= "111111111";
          ELSE 
            count_next <= add_temp_1(8 DOWNTO 0);
          END IF;
          is_Read_X_Y_Z_next <= IN_tCONV_delay;
        END IF;
    END CASE;

  END PROCESS Read_X_Y_Z_1_output;

  CSn <= CSn_reg_next;
  SCK <= SCK_reg_next;
  SDI <= SDI_reg_next;
  READ_SHIFT <= READ_SHIFT_reg_next;
  XYZ_Valid <= XYZ_Valid_reg_next;

END rtl;

